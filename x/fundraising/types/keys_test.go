package types_test

import (
	"testing"

	"github.com/stretchr/testify/suite"

	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/tendermint/tendermint/crypto"

	"github.com/tendermint/fundraising/x/fundraising/types"
)

type keysTestSuite struct {
	suite.Suite
}

func TestKeysTestSuite(t *testing.T) {
	suite.Run(t, new(keysTestSuite))
}

func (s *keysTestSuite) TestGetAuctionKey() {
	s.Require().Equal([]byte{0x21, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, types.GetAuctionKey(0))
	s.Require().Equal([]byte{0x21, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9}, types.GetAuctionKey(9))
	s.Require().Equal([]byte{0x21, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa}, types.GetAuctionKey(10))
}

func (s *keysTestSuite) TestGetAuctioneerKey() {
	auctioneer0 := sdk.AccAddress(crypto.AddressHash([]byte("auctioneer0")))
	auctioneer1 := sdk.AccAddress(crypto.AddressHash([]byte("auctioneer1")))
	auctioneer2 := sdk.AccAddress(crypto.AddressHash([]byte("auctioneer2")))
	s.Require().Equal([]byte{0x22, 0x14, 0xa2, 0xb2, 0xf6, 0xa1, 0x9b, 0x59, 0xc2, 0x70,
		0x68, 0xa9, 0x77, 0x8b, 0x4d, 0x95, 0x1a, 0x4a, 0x4, 0x2c, 0x36, 0x1}, types.GetAuctioneerKey(auctioneer0))
	s.Require().Equal([]byte{0x22, 0x14, 0xd6, 0x7d, 0x52, 0xf4, 0xc4, 0x39, 0xb1, 0x25,
		0x6, 0x6d, 0x2c, 0xcc, 0x8d, 0x24, 0xbb, 0x99, 0x64, 0x18, 0xa6, 0xeb}, types.GetAuctioneerKey(auctioneer1))
	s.Require().Equal([]byte{0x22, 0x14, 0x32, 0x42, 0xd4, 0x27, 0x91, 0x47, 0x8a, 0x7a,
		0x6, 0x9c, 0xed, 0xa4, 0xd9, 0xea, 0x64, 0x77, 0x55, 0xf7, 0x9b, 0xd6}, types.GetAuctioneerKey(auctioneer2))
}

func (s *keysTestSuite) TestGetSequenceKey() {
	testCases := []struct {
		auctionID uint64
		sequence  uint64
		expected  []byte
	}{
		{
			uint64(1),
			uint64(1),
			[]byte{0x21, 0x5, 0x73, 0x74, 0x61, 0x6b, 0x65, 0xd3, 0x7a, 0x85, 0xec, 0x75, 0xf, 0x3,
				0xaa, 0xe5, 0x36, 0xcf, 0x1b, 0xb7, 0x59, 0xb7, 0xbc, 0xbd, 0x5c, 0xfe, 0x3d},
		},
		{
			uint64(2),
			uint64(2),
			[]byte{0x21, 0x5, 0x73, 0x74, 0x61, 0x6b, 0x65, 0x15, 0x1, 0x20, 0x25, 0x5a, 0x5d, 0xe8,
				0x6b, 0xa1, 0xed, 0xfb, 0x6f, 0x45, 0x48, 0xcb, 0xfb, 0x6f, 0x28, 0x66, 0xf3},
		},
		{
			uint64(3),
			uint64(3),
			[]byte{0x21, 0x5, 0x73, 0x74, 0x61, 0x6b, 0x65, 0xdf, 0xb0, 0x6d, 0xbf, 0xc6, 0x9a, 0xcd,
				0xf5, 0x7b, 0xb, 0xe7, 0x69, 0x75, 0x50, 0x9e, 0x69, 0x54, 0xa6, 0x1e, 0xe2},
		},
	}

	for _, tc := range testCases {
		key := types.GetSequenceKey(tc.auctionID, tc.sequence)
		s.Require().Equal(tc.expected, key)

		// auctionID, sequence := types.ParseSequenceKey(key)
		// s.Require().Equal(tc.auctionID, auctionID)
		// s.Require().Equal(tc.sequence, sequence)
	}
}

func (s *keysTestSuite) TestGetBidKey() {
	// TODO: not implemented yet
}

func (s *keysTestSuite) TestGetBidderKey() {
	// TODO: not implemented yet
}
