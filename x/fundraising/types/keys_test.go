package types_test

import (
	fmt "fmt"
	"testing"

	"github.com/stretchr/testify/suite"

	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/tendermint/tendermint/crypto"

	"github.com/tendermint/fundraising/x/fundraising/types"
)

type keysTestSuite struct {
	suite.Suite
}

func TestKeysTestSuite(t *testing.T) {
	suite.Run(t, new(keysTestSuite))
}

func (s *keysTestSuite) TestGetAuctionKey() {
	s.Require().Equal([]byte{0x21, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, types.GetAuctionKey(0))
	s.Require().Equal([]byte{0x21, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9}, types.GetAuctionKey(9))
	s.Require().Equal([]byte{0x21, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa}, types.GetAuctionKey(10))
}

func (s *keysTestSuite) TestGetAuctioneerKey() {
	auctioneer0 := sdk.AccAddress(crypto.AddressHash([]byte("auctioneer0")))
	auctioneer1 := sdk.AccAddress(crypto.AddressHash([]byte("auctioneer1")))
	auctioneer2 := sdk.AccAddress(crypto.AddressHash([]byte("auctioneer2")))
	s.Require().Equal([]byte{0x22, 0x14, 0xa2, 0xb2, 0xf6, 0xa1, 0x9b, 0x59, 0xc2, 0x70,
		0x68, 0xa9, 0x77, 0x8b, 0x4d, 0x95, 0x1a, 0x4a, 0x4, 0x2c, 0x36, 0x1}, types.GetAuctioneerKey(auctioneer0))
	s.Require().Equal([]byte{0x22, 0x14, 0xd6, 0x7d, 0x52, 0xf4, 0xc4, 0x39, 0xb1, 0x25,
		0x6, 0x6d, 0x2c, 0xcc, 0x8d, 0x24, 0xbb, 0x99, 0x64, 0x18, 0xa6, 0xeb}, types.GetAuctioneerKey(auctioneer1))
	s.Require().Equal([]byte{0x22, 0x14, 0x32, 0x42, 0xd4, 0x27, 0x91, 0x47, 0x8a, 0x7a,
		0x6, 0x9c, 0xed, 0xa4, 0xd9, 0xea, 0x64, 0x77, 0x55, 0xf7, 0x9b, 0xd6}, types.GetAuctioneerKey(auctioneer2))
}

func (s *keysTestSuite) TestGetSequenceKey() {
	testCases := []struct {
		auctionID uint64
		sequence  uint64
		expected  []byte
	}{
		{
			uint64(1),
			uint64(1),
			[]byte{0x31, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1},
		},
		{
			uint64(2),
			uint64(2),
			[]byte{0x31, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2},
		},
		{
			uint64(3),
			uint64(3),
			[]byte{0x31, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3},
		},
	}

	for _, tc := range testCases {
		key := types.GetSequenceKey(tc.auctionID, tc.sequence)
		s.Require().Equal(tc.expected, key)

		fmt.Println("key: ", key)

		// auctionID, sequence := types.ParseSequenceKey(key)
		// s.Require().Equal(tc.auctionID, auctionID)
		// s.Require().Equal(tc.sequence, sequence)
	}
}

func (s *keysTestSuite) TestGetBidKey() {
	// TODO: not implemented yet
}

func (s *keysTestSuite) TestGetBidderKey() {
	// TODO: not implemented yet
}
